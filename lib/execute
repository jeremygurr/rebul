#!/bin/bash    # intended to be sourced from other scripts
# provides functions for abstracting command execution
# enables global pretend handling, as well as automatic trace logs
# examples: 
#   execute "echo Hello"           # will execute "echo Hello", printing "Hello"
#   pretend=t execute "echo Hello" # will only print "echo Hello"
#   trace=1 execute "echo Hello"   # will display "echo Hello" and execute it, printing "Hello"



type -t execute >/dev/null && return 0
execute() {

  try

    local command=${1%%*( )$NL*( )}
    command=${command##*( )$NL*( )}
    local show_command=${show_command:-f}
    local execute_command=t
    local out_to_var=${out_to_var:-}
    local out_to_file=${out_to_file:-}
    local err_to_var=${err_to_var:-}
    local secret=${secret:-none}
    local job_slot=${job_slot:-}   # for background jobs, which slot to use
    local background_timeout=${background_timeout:-5}    # for background jobs, how many seconds to wait
    local flush_timeout=${flush_timeout:-1}
    local pretend=${pretend:-f}

    [ $pretend == t -o $trace -gt 0 ] && show_command=t
    [ $pretend == t ] && execute_command=f

    local command_to_show=$command
    if [ "$secret" != none ]; then
      command_to_show=${command_to_show//$secret/**secret**}
    fi

    if [ $show_command == t ]; then
      if [ "$job_slot" ]; then
        trace=1 trace -n "[$job_slot] "
      fi
      trace=1 trace "$command_to_show" 
    fi

    execute_return_code=0
    if [ $execute_command == t ]; then

      local out_file err_file
      if [ "$out_to_var" ]; then
        reserve_tmp_file out_file execute_out
      elif [ "$out_to_file" ]; then
        out_file=$out_to_file
      fi

      [ "$err_to_var" ] && reserve_tmp_file err_file execute_err

      if [ "$job_slot" ]; then

        to_background_job "$command && echo __DONE__ || echo __FAILED__" || fail
        result=
        out_to_var=result stop_after=__DONE__ fail_after=__FAILED__ background_timeout=$background_timeout from_background_job || fail

        result="${result%\$ }"
        result="${result%\# }"
        result=$(echo "$result" | sed 's/__DONE__//g' | sed 's/__FAILED__//')

        # is this really needed? apparently it is
        trace "Flushing..."
        background_timeout=$flush_timeout flush_background_job

        if [ "$out_to_file" ]; then
          echo "$result" >"$out_to_file"
        elif [ "$out_to_var" ]; then
          result=$(echo "$result" | sed 's/"/\\"/g')
          eval "$out_to_var=\"$result\""
        else
          echo "$result" 
        fi

      else

        if [ "$out_to_var" -o "$out_to_file" ]; then
          if [ "$err_to_var" ]; then
            eval "$command" >$out_file 2>$err_file
            execute_return_code=$?
          else
            eval "$command" >$out_file
            execute_return_code=$?
          fi
        else
          if [ "$err_to_var" ]; then
            eval "$command" 2>$err_file
            execute_return_code=$?
          else
            eval "$command"
            execute_return_code=$?
          fi
        fi

        if [ "$out_to_var" ]; then
          eval "$out_to_var=\$(<$out_file)"
          rm $out_file &>/dev/null || true
        fi

        if [ "$err_to_var" ]; then
          eval "$err_to_var=\$(<$err_file)"
          rm $err_file &>/dev/null || true
        fi

      fi

    else

      if [ "$out_to_var" ]; then
        eval "$out_to_var=pretend"
      fi

      if [ "$err_to_var" ]; then
        eval "$err_to_var="
      fi
     
    fi

  end_try
  handle_return

}

