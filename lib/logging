#!/bin/bash
# contains general purpose logging functions

# err [{flags}] {message}     output an error message
# out [{flags}] {message}     output to stdout
# trace [{flags}] {message}   output a trace message if tracing level > 0

# {flags}                     -n means no newline


stack_trace() {
set +x
count=${#FUNCNAME[*]}

if [ ${tracing_tiny:-f} == t ]; then
  tracing_tiny=f
  echo
fi

echo "Stack trace:" >&2
for ((n = 1; n < count; n++)) ; do
  p=$((n - 1))
  echo "  ${BASH_SOURCE[$n]} ${FUNCNAME[$n]} ${BASH_LINENO[$p]}" >&2
done
}

# default for tracing messages is to go to stderr, but that can easily be overridden
exec 3>&2

# write output to standard error
#   can be overridden to provide a different behavior
err() {
  local flags=
  if [ "$1" == -n ]; then
    flags=-n
    shift
  fi

  if [ ${tracing_tiny:-f} == t ]; then
    tracing_tiny=f
    echo
  fi

  if [ ${trace_indent:-f} == t ]; then
    [ $trace -gt $trace_max ] && trace_max=$trace
    local pad_size=$((trace_max-trace))
    printf "%${pad_size}s" >&2
  fi

  echo $flags "${RED:-}ERROR: $1${RESET:-}" >&2
}

warn() {
  local flags=
  if [ "$1" == -n ]; then
    flags=-n
    shift
  fi

  if [ ${tracing_tiny:-f} == t ]; then
    tracing_tiny=f
    echo
  fi

  if [ ${trace_indent:-f} == t ]; then
    [ $trace -gt $trace_max ] && trace_max=$trace
    local pad_size=$((trace_max-trace))
    printf "%${pad_size}s" >&2
  fi

  echo $flags "${YELLOW:-}WARNING: $1${RESET:-}" >&2
}

alias deep='trace=$((trace-$deep_trace_level))'

tracing_tiny=f

# use this to print out a single character without a newline depending on trace level
trace_tiny() {
  local trace=${trace:-0}
  if [ $trace -lt 10 -a $trace -gt 0 ]; then
    if [ $tracing_tiny == f ]; then
      if [ ${trace_indent:-f} == t ]; then
        [ $trace -gt $trace_max ] && trace_max=$trace
        local pad_size=$((trace_max-trace))
        printf "%${pad_size}s" >&3
      elif [ ${trace_debug:-f} == t ]; then
        local pad_size=$((trace_max-trace))
        printf "%3d " $((pad_size+1)) >&3
      fi
      tracing_tiny=t
    fi

    echo >&3 -n "$@"
  fi

  return 0
}

trace() {
  local trace=${trace:-0}
  if [ $trace -gt 0 -o ${trace_force:-f} == t ]; then
    if [ $tracing_tiny == t ]; then
      echo >&3
      tracing_tiny=f
    fi
    if [ ${trace_indent:-f} == t ]; then
      [ $trace -gt $trace_max ] && trace_max=$trace
      local pad_size=$((trace_max-trace))
      printf "%${pad_size}s" >&3
    elif [ ${trace_debug:-f} == t ]; then
      local pad_size=$((trace_max-trace))
      printf "%3d " $((pad_size+1)) >&3
    fi

    echo >&3 "$@"
  fi

  return 0
}

trace_align() {
  local trace=${trace:-0}
  if [ $trace -gt 0 -o ${trace_force:-f} == t ]; then
    if [ $tracing_tiny == t ]; then
      echo >&3
      tracing_tiny=f
    fi
    if [ ${trace_indent:-f} == t ]; then
      [ $trace -gt $trace_max ] && trace_max=$trace
      local pad_size=$((trace_max-trace))
      printf "%${pad_size}s" >&3
    elif [ ${trace_debug:-f} == t ]; then
      local pad_size=$((trace_max-trace))
      printf "%3d " $((pad_size+1)) >&3
    fi

    echo_align >&3 "$@"
  fi

  return 0
}

out() {
  if [ ${tracing_tiny:-f} == t ]; then
    tracing_tiny=f
    echo
  fi
  echo "$@"
}

incomplete() {
  if [ ${tracing_tiny:-f} == t ]; then
    tracing_tiny=f
    echo
  fi
  if [ "$1" ]; then
    echo "Not implemented yet: ${1:-}" >&2
  else
    echo "Not implemented yet." >&2
  fi
  stack_trace
  exit 1
}

