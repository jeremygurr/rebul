#!/bin/bash

# echo_align behaves much like echo, except that it aligns columns based on the maximum size of previous lines
# echo_align_reset # will reset the column sizes
# echo_align -n "somestring" # will print the string but not end the line yet
# you can't combine the flags like -rn
# echo_align "string1" "string2" "string3" # the three strings will be in separate columns, possibly padded with spaces to make them align with the preceeding lines
#
# global vars
#   echo_current_column
#   echo_columns
#   echo_previous_column_size
#
# you can preset column widths like this:
#   echo_columns=( 20 10 40 )

echo_align() {
local output=()
local no_new_line no_new_column silent block=
local append
local rigid=f

while [[ $# -gt 0 ]]; do
  local key="$1"; shift

  case $key in
    -b|--block)
      silent=t
      block=t
    ;;
    -r|--rigid)
      rigid=t
    ;;
    -s|--silent)
      silent=t
    ;;
    -n|--no-new-line)
      no_new_line=t
    ;;
    -N|--no-new-column)
      no_new_column=t
    ;;
    *)
      output+=("$key")
    ;;
  esac
done

if [ ${tracing_tiny:-f} == t ]; then
  tracing_tiny=f
  echo
fi

if [ "$block" ]; then
  echo_block+=( "${output[*]}" )
fi

local column_text column_text_size column_max pad_size pad output_column_count echo_columns_count current_column

echo_current_column=${echo_current_column:-0}
echo_previous_column_size=${echo_previous_column_size:-0}
echo_min_pad=${echo_min_pad:-1}

output_column_count=${#output[*]}
let output_column_count+=echo_current_column

if [ "${echo_columns:-}" ]; then
  echo_columns_count=${#echo_columns[*]}
else
  echo_columns_count=0
fi

[ $echo_columns_count -gt $output_column_count ] && output_column_count=$echo_columns_count

current_column=0
for column_text in "${output[@]:-}"; do
  let current_column++ || true
  # only pad if we aren't the last column
  if [ $current_column -lt $output_column_count -o "$no_new_line" ]; then
    column_max=${echo_columns[$echo_current_column]:-0}
    column_text_size=${#column_text}
    let column_text_size+=echo_previous_column_size || true

    if [[ $column_text_size -gt $column_max ]]; then
      column_max=$column_text_size
      pad_size=$echo_min_pad

      if [ $rigid == f ]; then
        echo_columns[$echo_current_column]=$column_max
      fi
      [ "${echo_debug:-}" ] && echo_debug
    else
      let pad_size=column_max-column_text_size+echo_min_pad || true
    fi

    if [ ! "$no_new_column" ]; then
      [ "$pad_size" -le 0 ] && pad_size=$echo_min_pad
      printf -v pad %${pad_size}s
      column_text="${column_text}${pad}"
    fi
  fi
  let echo_current_column++ || true

  [ ! "$silent" ] && echo -n "$column_text"
done

if [ ! "$no_new_line" ]; then
  [ ! "$silent" ] && echo
  echo_current_column=0
fi

if [ "$no_new_column" ]; then
  echo_previous_column_size=$column_text_size
else
  echo_previous_column_size=0
fi

return 0
}

echo_align_reset() {
unset echo_columns
echo_block=( )
echo_current_column=0
}

echo_debug() {
echo
echo "echo_columns=( ${echo_columns[*]:-} )"
echo "echo_current_column=${echo_current_column:-0}"
}

# example: {complex command} | echo_align_stream 
echo_align_stream() {
local line line_array
while IFS= read -r line || [ "${line:-}" ]; do
  line_array=( $line )
  echo_align "${line_array[@]}"
  unset line
done
}

# example: {complex command} | echo_align_block
# will read the whole input at once, and determine alignment, then output it
# this is the opposite of echo_align_stream
echo_align_block() {
local line line_array block=()
while IFS= read -r line || [ "${line:-}" ]; do
  line_array=( $line )
  echo_align -b "${line_array[@]:-}"
  unset line
done

echo_align_dump
}

echo_align_dump() {
for line in "${echo_block[@]:-}"; do
  line_array=( $line )
  echo_align "${line_array[@]:-}"
done
}

